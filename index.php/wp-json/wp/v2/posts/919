{"id":919,"date":"2022-12-10T16:27:45","date_gmt":"2022-12-10T16:27:45","guid":{"rendered":"https:\/\/plainswipe.com\/?p=919"},"modified":"2022-12-10T16:27:45","modified_gmt":"2022-12-10T16:27:45","slug":"rlhf-tutorial-using-trlx","status":"publish","type":"post","link":"http:\/\/localhost:8000\/index.php\/rlhf-tutorial-using-trlx\/","title":{"rendered":"RLHF (Reinforcement Learning with Human Feedback) Python tutorial using TRLX"},"content":{"rendered":"\n<h4 class=\"wp-block-heading\">What is TRLX?<\/h4>\n\n\n\n<p>TRLX is a framework that uses Hugging Face transformers pipeline object to fine tune a model using RLHF. <\/p>\n\n\n\n<p>Transformer Reinforcement Learning X (TRLX) is a type of artificial intelligence (AI) that combines the capabilities of the Transformer model with reinforcement learning. The Transformer model is a powerful AI technique that is commonly used in natural language processing tasks, such as language translation or text summarization. Reinforcement learning is a type of machine learning that involves rewarding or punishing a model based on its actions in order to improve its performance over time.<\/p>\n\n\n\n<p>By combining these two techniques, TRLX allows robots to learn and adapt their behavior based on feedback from their environment and users. For example, a robot that uses TRLX might be trained to perform a specific task, such as cleaning a room or picking up objects. As the robot performs the task, it receives feedback from its sensors and users, and uses this feedback to adjust its behavior and improve its performance.<\/p>\n\n\n\n<p>TRLX has the potential to improve the performance and efficiency of robots in a wide range of applications, including manufacturing, logistics, and customer service. By allowing robots to learn and adapt based on feedback from their environment and users, TRLX can help robots to become more intelligent, flexible, and useful.<\/p>\n\n\n\n<h4 class=\"wp-block-heading\">What is RLHF?<\/h4>\n\n\n\n<p>RLHF stands for Reinforcement Learning with Human Feedback. <\/p>\n\n\n\n<div class=\"wp-block-media-text is-stacked-on-mobile\"><figure class=\"wp-block-media-text__media\"><img decoding=\"async\" src=\"https:\/\/plainswipe.com\/wp-content\/uploads\/2022\/12\/65249_ateacherstandingnexttoastudentscoringtheworkofthes.png\" alt=\"\" class=\"wp-image-927 size-full\"\/><\/figure><div class=\"wp-block-media-text__content\">\n<p>RLHF, or Reinforcement Learning from Human Feedback, is a type of artificial intelligence (AI) that allows robots to learn and improve their behavior based on feedback from human users. This is different from traditional AI, which is pre-programmed with a set of rules and behaviors that it follows without adapting to its environment or users.<\/p>\n\n\n\n<p>RLHF uses a technique called reinforcement learning, which involves rewarding the robot for behaviours that are beneficial to the user, and punishing the robot for behaviours that are harmful or undesirable. Over time, this reinforcement process helps the robot to learn and adapt its behavior to better meet the needs and preferences of its human users.<\/p>\n\n\n\n<p> <\/p>\n<\/div><\/div>\n\n\n\n<p><\/p>\n\n\n\n<h4 class=\"wp-block-heading\">Step 1 : Installation<\/h4>\n\n\n\n<pre class=\"wp-block-code\"><code>!git clone https:\/\/github.com\/CarperAI\/trlx.git\n%cd trlx\n!pip install torch --extra-index-url https:\/\/download.pytorch.org\/whl\/cu116\n!pip install -e .<\/code><\/pre>\n\n\n\n<h4 class=\"wp-block-heading\">Step 2: Setting up the environment<\/h4>\n\n\n\n<pre class=\"wp-block-code\"><code>from datasets import load_dataset\nfrom transformers import pipeline\nimport os\nimport yaml\n\nimport trlx\nimport torch\nfrom typing import List\nfrom trlx.data.configs import TRLConfig<\/code><\/pre>\n\n\n\n<h4 class=\"wp-block-heading\">Step 3: Fine Tune your Language Model (optional)<\/h4>\n\n\n\n<p>This is an optional step but highly recommended for serious applications. We pick GPT because it is particularly good at text generation tasks. Here is an example of code that shows how to fine-tune a Hugging Face GPT language model:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># Import the Hugging Face transformers library\nimport transformers\n\n# Load the GPT language model that you want to fine-tune\nmodel = transformers.GPT2LMHeadModel.from_pretrained('&lt;model_name&gt;')\n\n# Set the training parameters, such as the batch size and number of epochs\nbatch_size = 16\nnum_epochs = 5\n\n# Define the dataset and dataloader for the model\ndataset = transformers.LineByLineTextDataset(...)\ndataloader = transformers.DataLoader(...)\n\n# Set the optimizer and learning rate for the model\noptimizer = transformers.AdamW(model.parameters(), lr=2e-5)\n\n# Train the model for the specified number of epochs\nfor epoch in range(num_epochs):\n    # Train the model on the training data\n    model.train()\n    for batch in dataloader:\n        optimizer.zero_grad()\n        outputs = model(input_ids=batch&#91;'input_ids'], attention_mask=batch&#91;'attention_mask'])\n        loss = outputs&#91;0]\n        loss.backward()\n        optimizer.step()\n\n# Save the fine-tuned model\nmodel.save_pretrained('&lt;model_name&gt;')\n<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<div class=\"wp-block-media-text has-media-on-the-right is-stacked-on-mobile\"><div class=\"wp-block-media-text__content\">\n<p>This code shows the basic steps for fine-tuning a Hugging Face language model. First, the model is loaded from a pre-trained checkpoint. Next, the training parameters, such as the batch size and number of epochs, are set. The dataset and dataloader are then defined, and the optimizer and learning rate are set for the model.<\/p>\n\n\n\n<p>Finally, the model is trained for the specified number of epochs, using the training data provided in the dataloader. After training, the fine-tuned model is saved and loaded in the next step.<\/p>\n<\/div><figure class=\"wp-block-media-text__media\"><img decoding=\"async\" src=\"https:\/\/plainswipe.com\/wp-content\/uploads\/2022\/12\/457184_batmanoperatingtheradiointhecarCinematicextremelyd.png\" alt=\"\" class=\"wp-image-928 size-full\"\/><\/figure><\/div>\n\n\n\n<h4 class=\"wp-block-heading\">Step 4: Create a pipeline<\/h4>\n\n\n\n<p><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>sentiment_fn = pipeline(\n        \"sentiment-analysis\",\n        \"lvwerra\/distilbert-imdb\",\n        top_k=2,\n        truncation=True,\n        batch_size=256,\n        device=device,\n    )<\/code><\/pre>\n\n\n\n<p>In the code above we used the pre-trained model lvwerra\/distilbert-imdb and the sentiment analysis pipeline, but it could have been your fine tuned model and a different pipeline. The Hugging Face transformers provide a variety of pipelines that can be used for different natural language processing tasks. Some of the pipelines that are available include:<\/p>\n\n\n\n<ul>\n<li>Sentiment analysis: This pipeline can be used to predict the sentiment (positive, neutral, or negative) of a given text.<\/li>\n\n\n\n<li>Text generation: This pipeline can be used to generate new text based on a given prompt or input.<\/li>\n\n\n\n<li>Text classification: This pipeline can be used to classify a given text into one or more pre-defined categories.<\/li>\n\n\n\n<li>Named entity recognition: This pipeline can be used to identify and extract named entities (such as people, organizations, or locations) from a given text.<\/li>\n\n\n\n<li>Question answering: This pipeline can be used to generate answers to questions based on a given text or document.<\/li>\n\n\n\n<li>Summarization: This pipeline can be used to generate a concise summary of a given text or document.<\/li>\n\n\n\n<li>Translation: This pipeline can be used to translate a given text from one language to another.<\/li>\n<\/ul>\n\n\n\n<p>These are just a few examples of the pipelines that are available with the Hugging Face transformers. There are many other pipelines available, and new ones are being added all the time.<\/p>\n\n\n\n<h4 class=\"wp-block-heading\">Step 5: Create prompts<\/h4>\n\n\n\n<pre class=\"wp-block-code\"><code>    # Take few words off of movies reviews as prompts\n    imdb = load_dataset(\"imdb\", split=\"train+test\")\n    prompts = &#91;\" \".join(review.split()&#91;:4]) for review in imdb&#91;\"text\"]]<\/code><\/pre>\n\n\n\n<p>There are several different ways that you can create prompts. Some of the most common methods include:<\/p>\n\n\n\n<ul>\n<li>Using a pre-defined prompt: Many language models come with a set of pre-defined prompts that can be used to generate text or answers to questions. For example, a language model might include prompts such as &#8220;Tell me a story about a robot&#8221; or &#8220;Explain the concept of reinforcement learning in simple terms.&#8221;<\/li>\n\n\n\n<li>Providing your own prompt: In many cases, you can also create your own custom prompts by providing a sentence, paragraph, or other text as input to the language model. For example, you might provide a prompt such as &#8220;Describe the benefits of using a large language model&#8221; or &#8220;Write a poem about the beauty of nature.&#8221;<\/li>\n<\/ul>\n\n\n\n<p>In the move review dataset we simply truncated and used the first 5 words as the prompt. The prompt will be what you have fine-tuned your model to do. <\/p>\n\n\n\n<h4 class=\"wp-block-heading\">Step 6: Reward Function<\/h4>\n\n\n\n<pre class=\"wp-block-code\"><code>def get_positive_score(scores):\n    \"Extract value associated with a positive sentiment from pipeline's output\"\n    return dict(map(lambda x: tuple(x.values()), scores))&#91;\"POSITIVE\"]\n\ndef reward_fn(samples: List&#91;str]) -&gt; List&#91;float]:\n        sentiments = list(map(get_positive_score, sentiment_fn(samples)))\n        return sentiments<\/code><\/pre>\n\n\n\n<p>What this code is doing is taking the output of the pipeline, i.e. output of the prompts that you created earlier, and then scoring that output. Since in this sample example we are trying to use RLHF to generate positive reviews, we are only returning back the confidence score of the positive sentiment classification. This is key<\/p>\n\n\n\n<p>To illustrate with another example. Imagine you have a text classification model that classifies text into various classes (For instance, Factual, Opinionated, Impactful, and Useful), and your goal is to train a model to generate more Useful text then you simply return the Useful score of the classification. <\/p>\n\n\n\n<p>Do note that in the example above the output of the sentiment analysis pipeline in itself is a classification (Positive, Negative), but in case of text generation models like GPT you could have taken the output of the prompt and fed that output into a different text classification model, and taken the scores of the class you care about (e.g. Useful class) and then made that was the reward.<\/p>\n\n\n\n<p>I hope you can see the immense power behind this training technique. The rewards could be coming from another model, or could be coming directly from some human raters (e.g. Amazon Mechanical Turk). In Chat GPT they went ahead and first collected ratings from human raters and then fine-tuned a language model on predicting the ratings given the pair of prompt, and generated text.<\/p>\n\n\n\n<h4 class=\"wp-block-heading\">Step 7: Train using TRLX library<\/h4>\n\n\n\n<pre class=\"wp-block-code\"><code> model = trlx.train(\n        reward_fn=reward_fn,\n        prompts=prompts,\n        eval_prompts=&#91;\"I don't know much about Hungarian underground\"] * 64,\n        config=config,\n    )<\/code><\/pre>\n\n\n\n<p>eval_prompts are prompts to periodically validate training on. The idea is that theses prompts will never be used in learning, but purely as a way to evaluate the training. In the example above is a primitive way to give a list of 64 prompts all repeated but in a real example these would be carefully selected prompts.<\/p>\n\n\n\n<h4 class=\"wp-block-heading\">Conclusion<\/h4>\n\n\n\n<p>So there you have it, in this post I covered the logical structure of how to do RLHF training (Reinforcement Learning from Human Feedback). I intentionally skipped many details to make sure this tutorial is intuitive. In the next part I am going to cover how to actually run this training, since it can be computationally expensive. I will be focussing on the real challenges of running this training in a cost effective manner. I will be trying to make this run on a Google Colab, and will share my learnings. So stay tuned or subscribe.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>What is TRLX? TRLX is a framework that uses Hugging Face transformers pipeline object to fine tune a model using RLHF. Transformer Reinforcement Learning X (TRLX) is a type of artificial intelligence (AI) that combines the capabilities of the Transformer model with reinforcement learning. The Transformer model is a powerful AI technique that is commonly&hellip;&nbsp;<a href=\"http:\/\/localhost:8000\/index.php\/rlhf-tutorial-using-trlx\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">RLHF (Reinforcement Learning with Human Feedback) Python tutorial using TRLX<\/span><\/a><\/p>\n","protected":false},"author":1,"featured_media":928,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":"","_themeisle_gutenberg_block_has_review":false,"_ti_tpc_template_sync":false,"_ti_tpc_template_id":""},"categories":[5],"tags":[17,27,46,48,88,89,111,112],"_links":{"self":[{"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/posts\/919"}],"collection":[{"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/comments?post=919"}],"version-history":[{"count":0,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/posts\/919\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/"}],"wp:attachment":[{"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/media?parent=919"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/categories?post=919"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost:8000\/index.php\/wp-json\/wp\/v2\/tags?post=919"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}